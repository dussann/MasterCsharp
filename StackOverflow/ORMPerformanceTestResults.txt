-Batch insert je potrbno koristiti kako bi se izbegao outOfMemmoryException
(povecava se Java Heap, a to je valjda povezano sa RAM memorijom i sistem kesom )
GenerationType.IDENTITY ne podrzava Batch processing
-A connection pool is used to minimize the number of connections opened between application and database
-When using PostgreSQL or MySQL, you don’t have to worry about the fetch size since the JDBC driver caches the entire result set up front,
 so there’s a single database roundtrip to materialize the result set and make it available to the application.


-ADO.net has a better performance as it is directly connected to the data source which makes the processing much faster then EF core
 as it first translate LINQ queries to SQL and then process the query.
-Entity states
Every entity is associated with a given EntityState:
	Detached entities are not being tracked by the DbContext.
	Added entities are new and have not yet been inserted into the database. This means they will be inserted when SaveChanges is called.
	Unchanged entities have not been changed since they were queried from the database. All entities returned from queries are initially in this state.
	Modified entities have been changed since they were queried from the database. This means they will be updated when SaveChanges is called.
	Deleted entities exist in the database, but are marked to be deleted when SaveChanges is called.

=========CREATE=========
Create user
	Hibernate - 65 ms
	Entity - 90 ms
	
Create users 1000
	Hibernate - 2100 ms
	Entity - 550 ms
	
Create users 10000
	Hibernate - 11500 ms
	Entity - 2250 ms

Create users 100000
	Hibernate - 19100 ms
	Entity - 21394 ms
	
Create users 500000
	Hibernate - 98750 ms
	Entity - 107527 ms
=========READ===========
Read user
	Hibernate - 70 ms
	Entity - 1306 ms
	
Read user 1000
	Hibernate - 118 ms
	Entity - 1250 ms

Read user 10000
	Hibernate - 204 ms
	Entity - 1340 ms


Read user 100000
	Hibernate - 834 ms
	Entity - 1853 ms


Read user 500000
	Hibernate - 2879 ms
	Entity - 3541 ms